[{"categories":["Data-scraping"],"content":"R is a popular language for scraping websites and has plenty of packages for scraping static websites. However, dynamically generated websites are growing in popularity. These are harder to scrape, as the content is generated after we load the website or do some events on the website. Luckily, R has a solution even for this. Package RSelenium which enables us to connect to the Selenium server. You can learn more about this package from its vignette. In this tutorial, I am going to show you, how to scrape websites with infinite scrolling. RSelenium preparation And what better place to scrape, than the one we like to waste time on. That’s right we are going to scrape data from youtube. First of all, it is polite to check if the scraping is allowed. We can check robots.txt for youtube to see if youtube is fine with us, scraping it. As there are no restrictions we are fine to continue. As a first step, we need to start the Selenium server and browser and open it. We will use headless Firefox, as we do not need to see, what is happening and we want to scrape in the background. We do all this with the following code: rD \u003c- RSelenium::rsDriver(port = 4485L, browser = \"firefox\", extraCapabilities = list( \"moz:firefoxOptions\" = list( args = list('--headless') ) ) ) remDr \u003c- rD$client remDr$open() Now with our browser ready, we can navigate it to youtube. remDr$navigate(\"https://www.youtube.com\") After this step, we should be ready to scrape video metadata. We will scrape a video title, a video uploader, and a video URL. We can get all the videos on the title page with the following CSS selector: #contents #details #meta. To get the elements with our selenium browser, we just need to use the findElements method. videoEls \u003c- remDr$findElements(using = \"css\", \"#contents #details #meta\") And now it’s time to return the data in the structured form out of the Selenium browser. We can create a small function, that will return data.frame with the information we need. Scraping the data getVideoDetails \u003c- function(videoEl) { titleEl \u003c- videoEl$findChildElement(\"css\",\"#video-title-link\") metadataEl \u003c- videoEl$findChildElement(\"css\",\"#metadata\") URL \u003c- titleEl$getElementAttribute(\"href\")[[1]] title \u003c- titleEl$getElementText()[[1]] uploaderName \u003c- metadataEl$findChildElement(\"css\", \"#byline-container\")$getElementText()[[1]] data.frame(URL = URL, title = title, uploaderName = uploaderName, stringsAsFactors = FALSE) } As the last step, we will call this function on each element of the videoEls list that we have selected. details \u003c- lapply(videoEls, getVideoDetails) %\u003e% dplyr::bind_rows() Time to scroll But what about this dynamic content that is generated when we scroll? We will need to select a page element, that we will use for scrolling. The body element is ideal for this, as it wraps the whole web page. After that, we will move to the end of said element. However, as it is infinite scrolling, we will do it just 10 times. bodyEl \u003c- remDr$findElement(\"css\", \"body\") for (i in 1:10) { bodyEl$sendKeysToElement(list(key = \"end\")) Sys.sleep(5) } You might have noticed Sys.sleep function in the loop. It is a good practice to wait a while, between doing requests on the website. Here it is especially important, as we need to wait until our webpage loads the new dynamically generated data. After that, we can once again get all the elements using our CSS selector and scrape the details of videos. videoEls \u003c- remDr$findElements(using = \"css\", \"#contents #details #meta\") videoDetailsScrolled \u003c- lapply(videoEls , getVideoDetails) %\u003e% dplyr::bind_rows() And that’s it. As you can see videoDetailsScrolled has more rows than details because we have scrolled down 10 times which generated more videos for us to scrape. I hope that you find this tutorial useful and now know, how to tackle those pesky dynamically generated websites. See you in the next post and scrape responsibly! ","date":"2020-06-22","objectID":"/2020-06-22-scraping-data-from-website-with-infinite-scrolling/:0:0","tags":["Data-scraping","R","Selenium"],"title":"Scraping data from website with infinite scrolling","uri":"/2020-06-22-scraping-data-from-website-with-infinite-scrolling/"},{"categories":["Design patterns"],"content":"In my previous post, we have been creating a package with a connection to the database. However, this connection was exposed as a global object, which could then be freely accessed by anyone. I didn’t like this approach, so I have decided to try to find a way how to encapsulate it and hide this object from the user of the package. As someone, who used to work with Java and Scala before transitioning to R, singleton immediately came into my mind. However I have not worked with object-oriented programming in R. So I have studied a little bit about all the different class systems in R. From all the possible class systems, reference classes are the most similar to the Java classes as the objects are for example mutable. However, this mutability does not go hand in hand with the more functional design in R, so I have decided to create something similar to a singleton in the S4 system. Singleton First of all, we need to create new S4 class. setClass(\"singleton\") Then we need to create a constructor for the class. Singleton pattern should create a new object only if it does not exist yet, otherwise, it should return an already existing instance of the object. For this, we can use function closure. In this closure, we will have a list which will keep all instances of the already created objects. We use a list because we might want to create a sub-class of the singleton. closureFun \u003c- function() { singleton \u003c- list() function(.Object, ...) { arguments \u003c- list(...) if (is.null(singleton[[class(.Object)]])) { for (slotName in intersect(slotNames(.Object), names(arguments))) { slot(.Object, slotName) \u003c- arguments[[slotName]] } singleton[[class(.Object)]] \u003c\u003c- .Object } singleton[[class(.Object)]] } } setMethod(f=\"initialize\", signature(.Object = \"singleton\"),closureFun()) And that’s it. Now, we can create two subclasses, which will inherit from a singleton. These classes will save the object created with the first call of new function and each subsequent call will return the same object. We can try this with the following example. setClass(\"subClass1\", slots = c(name = \"character\"), contains = \"singleton\") setClass(\"subClass2\", slots = c(age = \"numeric\"), contains = \"singleton\") type1child1 \u003c- new(\"subClass1\", name = \"abc\") type2child1 \u003c- new(\"subClass2\", age = 5) type1child2 \u003c- new(\"subClass1\", name = \"newName\") type2child2 \u003c- new(\"subClass2\", age = 55) But as mentioned earlier, this object is not 100% true singleton, as the change on this object won’t be propagated to the object saved in the list, so you can have desynchronized objects. To be safe, you should never change the object outside of the constructor function. ","date":"2020-06-12","objectID":"/2020-06-12-creating-singleton-pattern-in-s4/:0:0","tags":["R","OOP","S4","Design patterns"],"title":"Creating singleton pattern in S4","uri":"/2020-06-12-creating-singleton-pattern-in-s4/"},{"categories":["Data-scraping"],"content":"It is always interesting to go back to your older projects. You can spot, how is your coding style evolving, and how you, as a programmer, are improving. Recently, I had to go through the code of one of my first projects in R and boy, was it a mess. It was supposed to download Financial Statements of all the businesses in Slovakia for a certain year. It worked, barely. But trying to understand the code was a pain. No functions, random variable names, no documentation… There was even a public API, but for some reason (and I am sure, that at a time It was a “great” one), I have decided not to use it but to scrape web pages directly. So I have decided this is a great opportunity to see, how would I do things now, and finally do this code some justice and banish this abomination that I have once called code. Public API First of all, we have to take a look at a public API endpoints and data model. Its full documentation can be found here. From the data model, we are interested in accounting entities and financial statements. It is also possible to see an expected output from the endpoints, which we will use for preparing our database tables. Project structure This time, things should be done right, that’s why I have decided to create an R package. This is a first step, that will give this project an initial structure. This also gives developer bigger control over which packages are used, which functions we want to export, and a lot more. All these great features come at almost no cost, so there is no reason not to create an R package. If you haven’t created an R package before, Hadley has a great tutorial on how to do things right. In the previous project, data were saved as .csv files which were the manually concated. Now we want to have downloaded data stored reasonably. Because of the relational nature of the data, we will use the PostgreSQL database. Preparing database After you install your PostgreSQL database, we need to create tables, where we will store our data. All the tables can be created with the following script: CREATE TABLE financial_report_for_financial_statement ( id serial PRIMARY KEY, id_financial_statement VARCHAR (10), id_financial_report VARCHAR (10) ); CREATE TABLE financial_report_title ( id serial PRIMARY KEY, id_financial_report VARCHAR (10), nazovUctovnejJednotky VARCHAR (500), ico VARCHAR (8), dic VARCHAR (10), adresa VARCHAR (500), skNace VARCHAR (100), typZavierky VARCHAR (30), obdobieOd DATE, obdobieDo DATE, predchadzajuceObdobieOd DATE, predchadzajuceObdobieDo DATE, datumSchvalenia DATE, datumZostavenia DATE, oznacenieObchodnehoRegistra VARCHAR (100), type VARCHAR (3) ); CREATE TABLE financial_report_base ( id serial PRIMARY KEY, id_financial_report VARCHAR (10), pristupnostDat VARCHAR (20), datumPoslednejUpravy DATE, zdrojDat VARCHAR(20), kodDanovehoUradu VARCHAR(20), idSablony VARCHAR(20) ); DO language 'plpgsql' $$ DECLARE mujAkt text := 'CREATE TABLE financial_report_assets_muj(id serial PRIMARY KEY, id_financial_report varchar(10),' || string_agg('V' || i::text || ' integer', ',') || ');' FROM generate_series(1,46) As i; DECLARE mujPas text := 'CREATE TABLE financial_report_lae_muj(id serial PRIMARY KEY, id_financial_report varchar(10),' || string_agg('V' || i::text || ' integer', ',') || ');' FROM generate_series(1,44) As i; DECLARE mujZS text := 'CREATE TABLE financial_report_is_muj(id serial PRIMARY KEY, id_financial_report varchar(10),' || string_agg('V' || i::text || ' integer', ',') || ');' FROM generate_series(1,76) As i; DECLARE podAkt text := 'CREATE TABLE financial_report_assets_pod(id serial PRIMARY KEY, id_financial_report varchar(10),' || string_agg('V' || i::text || ' integer', ',') || ');' FROM generate_series(1,312) As i; DECLARE podPas text := 'CREATE TABLE financial_report_lae_pod(id serial PRIMARY KEY, id_financial_report varchar(10),' || string_agg('V' || i::text || ' integer', ',') || ');' FROM generate_series(1,134) As i; DECLARE podZS text := 'CREATE TABLE financial_repor","date":"2020-06-07","objectID":"/2020-06-07-scraping-financial-statements-of-slovak-financial-entities/:0:0","tags":["R","Data-scraping","PostgreSQL"],"title":"Scraping financial statements of Slovak financial entities","uri":"/2020-06-07-scraping-financial-statements-of-slovak-financial-entities/"},{"categories":null,"content":"I am currently working as an Application Developer for Zurich Insurance. I have a master’s degree in Information Systems from Slovak University of Technology in Bratislava, Faculty of Informatics and Information Technologies. My language of preference is R, but I also had my fair share of Java and Scala. ","date":"2020-06-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]